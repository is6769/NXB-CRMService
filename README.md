# Сервис CRM

## Описание

CRM-сервис — это компонент телекоммуникационной системы, отвечающий за управление взаимоотношениями с абонентами. Сервис предоставляет интерфейсы для выполнения операций абонентами и менеджерами.

## Назначение

CRM-сервис выполняет следующие функции:
- Регистрация новых абонентов
- Управление тарифными планами абонентов
- Пополнение баланса абонентами и менеджерами
- Получение информации об абоненте и его тарифе
- Обеспечение безопасного доступа к функциям через разделение ролей

## Архитектурные особенности

CRM-сервис взаимодействует с другими сервисами системы, в частности с BRT-сервисом (Billing Real-Time), выступая в роли фасада для конечных пользователей системы: абонентов и менеджеров.

### Взаимодействие с другими сервисами

- **BRT-сервис**: Выполняет основные операции биллинга (создание абонентов, установка тарифов, пополнение баланса)
- **SSO-сервис**: Обеспечивает аутентификацию и авторизацию пользователей
- **Config Server**: Получение конфигурации
- **Eureka Server**: Обнаружение сервисов

## Логика работы

### Модель безопасности

1. Запросы к CRM-сервису проходят через `HeadersFilter`
2. Фильтр извлекает заголовки безопасности:
   - `X-User-Id`: Идентификатор пользователя
   - `X-User-Role`: Роль пользователя (ROLE_MANAGER, ROLE_SUBSCRIBER)
3. На основе заголовков создается объект аутентификации и помещается в контекст безопасности
4. Spring Security выполняет авторизацию на основе ролей:
   - URLs `/manager/**` доступны только для ROLE_MANAGER
   - URLs `/subscriber/**` доступны только для ROLE_SUBSCRIBER

### Создание абонента

1. Менеджер отправляет запрос `POST /manager/subscriber` с данными нового абонента
2. `ManagerController` принимает и валидирует `SubscriberDTO`
3. `SubscribersService` делегирует запрос `BRTServiceClient.createSubscriber()`
4. BRT-сервис создает абонента и возвращает `SubscriberWithIdDTO`
5. Ответ возвращается менеджеру

### Установка тарифа

1. Менеджер отправляет запрос `PUT /manager/subscribers/{subscriberId}/tariff/{tariffId}`
2. `ManagerController` принимает идентификаторы абонента и тарифа
3. `SubscribersService` делегирует запрос `BRTServiceClient.setTariffForSubscriber()`
4. BRT-сервис устанавливает тариф и возвращает сообщение об успехе
5. Ответ возвращается менеджеру

### Пополнение баланса

#### Менеджером:
1. Менеджер отправляет запрос `PATCH /manager/subscribers/{subscriberId}/balance` с данными пополнения
2. `ManagerController` принимает и валидирует `TopUpDTO`
3. `SubscribersService` делегирует запрос `BRTServiceClient.topUpBalance()`
4. BRT-сервис пополняет баланс и возвращает сообщение об успехе
5. Ответ возвращается менеджеру

#### Абонентом:
1. Абонент отправляет запрос `PATCH /subscriber/balance` с данными пополнения
2. `SubscriberController` извлекает ID абонента из токена авторизации
3. `SubscribersService` делегирует запрос `BRTServiceClient.topUpBalance()`
4. BRT-сервис пополняет баланс и возвращает сообщение об успехе
5. Ответ возвращается абоненту

### Получение информации об абоненте

1. Менеджер отправляет запрос `GET /manager/subscribers/{subscriberId}`
2. `ManagerController` принимает идентификатор абонента
3. `SubscribersService` делегирует запрос `BRTServiceClient.getSubscriberAndTariffInfo()`
4. BRT-сервис возвращает `FullSubscriberAndTariffInfoDTO` с полной информацией об абоненте и его тарифе
5. Информация возвращается менеджеру

## API Endpoints

### API Менеджера

- `POST /manager/subscriber` - Создание нового абонента
- `PUT /manager/subscribers/{subscriberId}/tariff/{tariffId}` - Назначение тарифа абоненту
- `PATCH /manager/subscribers/{subscriberId}/balance` - Пополнение баланса абонента
- `GET /manager/subscribers/{subscriberId}` - Получение информации об абоненте и его тарифе

### API Абонента

- `PATCH /subscriber/balance` - Пополнение собственного баланса абонента

## Модели данных

### DTO-объекты для запросов

- **SubscriberDTO**: Данные для создания абонента
  - `msisdn`: Номер телефона (обязательное поле, должно содержать только цифры)
  - `firstName`: Имя абонента (обязательное поле)
  - `secondName`: Отчество абонента (опциональное поле)
  - `surname`: Фамилия абонента (обязательное поле)
  - `tariffId`: ID тарифного плана (опциональное поле, должно быть положительным)
  - `balance`: Начальный баланс (опциональное поле, должно быть неотрицательным)

- **TopUpDTO**: Данные для пополнения баланса
  - `amount`: Сумма пополнения (обязательное поле, должно быть >= 0.1)
  - `unit`: Единица измерения (обязательное поле, не пустое)

### DTO-объекты для ответов

- **SubscriberWithIdDTO**: Данные абонента с идентификатором
  - Все поля из SubscriberDTO
  - `id`: Уникальный идентификатор абонента

- **FullSubscriberAndTariffInfoDTO**: Информация об абоненте и его тарифе
  - `subscriber`: Объект SubscriberWithIdDTO
  - `tariff`: Объект TariffDTO

- **TariffDTO**: Информация о тарифе
  - `id`: Идентификатор тарифа
  - `name`: Название тарифа
  - `description`: Описание тарифа
  - `cycleSize`: Размер тарифного цикла (например, "30 дней")
  - `is_active`: Флаг активности тарифа
  - `tariffPackages`: Список пакетов услуг в тарифе

- **ServicePackageDTO**: Информация о пакете услуг
  - `id`: Идентификатор пакета
  - `name`: Название пакета
  - `description`: Описание пакета
  - `serviceType`: Тип услуги
  - `packageRules`: Список правил тарификации

## Обработка ошибок

- **RestExceptionsHandler**: Глобальный обработчик исключений
  - Обрабатывает исключения типа `HttpClientErrorException` и `HttpServerErrorException`
  - Сохраняет заголовки оригинального ответа (кроме Content-Length и Transfer-Encoding)
  - Пробрасывает клиенту исходный статус код и тело ответа
  - Для ошибок валидации возвращает `ExceptionDTO` со статусом 400 и типом "VALIDATION_EXCEPTION"

## Технический стек

- **Java 17**
- **Spring Boot 3.4.4**
- **Spring Cloud 2024.0.1**
  - Eureka Client (обнаружение сервисов)
  - Config Client (внешняя конфигурация)
- **Spring Security** (авторизация на основе ролей)
- **Spring Validation** (валидация входных данных)
- **Spring Web** (REST API)
- **RestClient** (взаимодействие с другими сервисами)
